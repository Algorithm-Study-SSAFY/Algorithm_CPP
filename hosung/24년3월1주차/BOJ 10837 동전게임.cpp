#include <iostream>
#include <cmath>

using namespace std;

/*
* 먼저 영희와 동수의 점수가 동점일 때와 아닐 때를 나누어 접근하였다.
* 동점일 때는 무조건 가능한 게임 점수이기 때문이다.
* 동점이 아닐 때는 dist(영희점수-동수점수)가 0보다 클 때와 작을 때를 나누어 접근하였다.
* 
* 1.영희가 점수가 높을 때 동수가 가질 수 있는 최소 점수를 생각해보았을 때
* K는 총 라운드이고, 영희가 받은 점수는 종료시점 라운드일 때 
* 남은 라운드에서 영희는 점수를 얻지 못하고 동수가 아슬하게 비벼볼 수 있는 상황이 연출되어야 가능한 점수라 할 수 있다
* 그렇지 않으면 연출될 수 없는 점수이다.
* 
* 남은 라운드는 K-M이고 종료된 라운드는 영희가 선공이기 때문에 남은 공격기회동안 점수를 다 얻어서
* 1점차로 지는 것은 가능하다 또한 그 때 선공인 영희만 점수를 따서 끝난 것이므로 2점차까지는 가능 점수다
* 따라서 (남은 라운드)+(동수점수) < (영희 점수 - 2)가 되면 불가능해진다
* 
* 2. 반대로 동수가 점수가 높을 때 영희가 가질 수 있는 최소 가능 점수를 보면,
* 동수가 후공으로 게임이 끝났을 때, 남은 라운드 동안 영희가 점수를 다 얻어서 1점차까지 얻는 것은 가능하다
* 그러나 그렇지 않으면 영희는 선공이므로 더 이상 비벼볼 가치가 없으므로 이미 승부는 끝났어야했다
* 따라서 (남은 라운드)+(영희 점수) < (동수 점수 - 1)가 되면 불가능해진다
*/

int K, C;

int main() {

    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> K >> C;

    for (int i = 0; i < C; i++) {
        int M, N;
        cin >> M >> N;

        int dist = M - N;
        if (dist == 0) cout << 1 << "\n";
        else {
            if (dist > 0) { //K - dist = (K - M) + N = (남은라운드)+(동수점수)
                if (K - dist < M - 2) cout << 0 << "\n";
                else cout << 1 << "\n";
            }
            else if (dist < 0) { //K + dist = (K - N) + M = (남은라운드)+(동수점수)
                if (K + dist < N - 1) cout << 0 << "\n";
                else cout << 1 << "\n";
            }
        }
        
    }

    return 0;
}



