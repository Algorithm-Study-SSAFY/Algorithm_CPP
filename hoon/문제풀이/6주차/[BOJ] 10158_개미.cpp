#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <cmath>
#include <string>

using namespace std;

/*
인풋 4만 -> 완탐은 불가능하다 생각
디저트카페가 떠올랐지만 칸 하나하나 확인하는 문제가 아니라 완탐은 X
좌표만 이동시키면 충분해서, 특정한 규칙이 있을거라 판단.
먼저 가로부터 생각해보면
시간이 t만큼이면 가로든 세로든 t만큼만 움직이는 규칙임.
좌표가 p면 t만큼 지나면 p+t 만큼 지나가지만, 벽에 부딛히면 되돌아감.
=> p+t에서 % w 연산을 거치면 가능하지 않을까?
=> 그러나, (p+t)%w 연산을 해버리면, 좌측에서부터 나머지만큼 이동한 만큼만 고려하게 됨.
=> 벽에 튕기는 경우 어떻게?
=> (p+t)/w가 홀수인지 짝수인지 판단하면 가능하겠구나!
=> 문제는 무조건 오른쪽 대각선으로 이동하는 것이 시작이니 p+t가 처음 w를 초과하는 순간은 몫이 1이고
    돌아가서 다시 튕기는 순간은 2겟구나! => 홀수 짝수로 어느 벽에 튕기는지 달라진다
=> 홀수 짝수별로 나눠서 홀수인 경우는 오른쪽 벽에서 튕기는 것이니 w에서 나머지만큼 빼주면 되겠구나
=> 짝수는 그 반대. 세로도 가로의 반대!

But 가로 끝에 도달하지 않고 세로에 도달에서 반사되는 경우
=> 신경 X 어차피 이 경우에는 남동쪽 방향으로 이동할것~
*/
int main()
{
    int w, h, p, q, t;
    cin >> w >> h >> p >> q >> t;
    if (((p + t) / w) % 2 == 0)
        cout << (p + t) % w << " ";
    else
        cout << w - (p + t) % w << " ";
    if (((q + t) / h) % 2 != 0)
        cout << h - (q + t) % h;
    else
        cout << (q + t) % h;
    return 0;
}